# 新插件的制作

***
	win64 直接在vs中创建一个工程KFNewName, 目录在KFPlugin下.
	linux 创建KFNewName目录, 并添加CMakeLists.txt, 添加 BUILD_PLUGIN_MACRO("KFNewName")
		  然后在在KFNewName目录下的CMakeLists.txt, 添加 add_subdirectory(KFNewName)

	KFNewName是新的插件名字, 这里只是一个代名词.
***
	创建KFNewNameInterface文件(.h), 声明抽象类, 继承KFModule. 具体请参考已有插件	
	尽量做好封装,以纯虚函数提供访问接口
	如果有提供接口, 需要定义一个接口变量, 供其他模块使用
    __KF_INTERFACE__( _kf_newname, 创建KFNewNameInterface );
***
	实现KFNewNameInterface接口,声明KFNewNameModule类(.h和.cpp),并实现自己定义的接口
	
	KFModule自带的接口, 主要如下:
	1. InitModule 初始化模块, 一般用于添加config和一些资源初始化阶段
	2. AfterLoad 配置加载完成以后 在这个函数里添加需要执行的逻辑
    3. BeforeRun 循环逻辑之前的资源准备
    4. OnceRun 在BeforeRun之后执行, 执行一次准备逻辑
    5. Run 逻辑循环, 有逻辑才继承
    6. AfterRun 逻辑循环后的逻辑 在Run之后执行, 每帧都会执行
    7. BeforeShut 关闭插件之前执行的逻辑
    8. ShutDown 关闭插件
    9. AfterShut 关闭插件之后执行的逻辑
    
	如实现BeforeRun
	    void KFNewNameModule::BeforeRun()
    	{
			std::cout << "hello world!" << std::endl;
    	}
***
	实现KFNewNamePlugin接口(.h和.cpp),继承KFPlugin. 具体请参考已有插件
	实现3个函数:
	1. Install  
		__REGISTER_MODULE__( KFNewName ); 把新模块注册到插件管理器
	2. UnInstall  
		__UNREGISTER_MODULE__( KFNewName ); 把新模块从插件管理器中卸载
	3. LoadModule
	    __FIND_MODULE__( _kf_xxxx, KFXXXXXInterface );
		如果有用到其他模块的函数, 在这个函数中初始化.没有请跳过
***
	在进程startup文件中, 或者新建一个newname.startup文件, 把新插件加入到文件中
		如:	<Plugin Sort="1" Name="KFNewName" Config=""/>
***
	使用启动器启动, 并加载新的插件配置
	命令行中输入:
	win64  start "newname" bin/KFStartupd.exe appid=100.0.0.1 log=0.0 startup=./startup/newname.startup 
	linux ./bin/KFStartupd appid=100.0.0.1 log=0.0 startup=./startup/newname.startup daemon=0
	启动后看到控制台打印出hello world!
***
	到这里简单的插件就已经完成, 更多的功能请自己写代码实现.

